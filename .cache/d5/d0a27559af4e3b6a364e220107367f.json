{"id":"node_modules/algorithms/algorithms/graph/bellman_ford.js","dependencies":[{"name":"C:\\Users\\crist\\MyGitProjects\\MyWebProjects\\myWebApp\\package.json","includedInParent":true,"mtime":1588264908566},{"name":"C:\\Users\\crist\\MyGitProjects\\MyWebProjects\\myWebApp\\node_modules\\algorithms\\package.json","includedInParent":true,"mtime":1588264908519}],"generated":{"js":"'use strict';\n\n/**\n * Calculates the shortest paths in a graph to every node\n * from the node 'startNode' with Bellman-Ford's algorithm\n *\n * Worst Case Complexity: O(|V| * |E|), where |V| is the number of\n * vertices and |E| is the number of edges in the graph\n *\n * @param Object 'graph' An adjacency list representing the graph\n * @param String 'startNode' The starting node\n * @return Object the minimum distance to reach every vertice of\n *    the graph starting in 'startNode', or an empty object if there\n *    exists a Negative-Weighted Cycle in the graph\n */\nvar bellmanFord = function (graph, startNode) {\n  var minDistance = {};\n  var previousVertex = {};\n  var edges = [];\n  var adjacencyListSize = 0;\n\n  // Add all the edges from the graph to the 'edges' array\n  graph.vertices.forEach(function (s) {\n    graph.neighbors(s).forEach(function (t) {\n      edges.push({\n        source: s,\n        target: t,\n        weight: graph.edge(s, t)\n      });\n    });\n\n    minDistance[s] = Infinity;\n    ++adjacencyListSize;\n  });\n\n  minDistance[startNode] = 0;\n\n  var edgesSize = edges.length;\n  var sourceDistance;\n  var targetDistance;\n\n  var iteration;\n  for (iteration = 0; iteration < adjacencyListSize; ++iteration) {\n    var somethingChanged = false;\n\n    for (var j = 0; j < edgesSize; j++) {\n      sourceDistance = minDistance[edges[j].source] + edges[j].weight;\n      targetDistance = minDistance[edges[j].target];\n\n      if (sourceDistance < targetDistance) {\n        somethingChanged = true;\n        minDistance[edges[j].target] = sourceDistance;\n        previousVertex[edges[j].target] = edges[j].source;\n      }\n    }\n\n    if (!somethingChanged) {\n      // Early stop.\n      break;\n    }\n  }\n\n  // If the loop did not break early, then there is a negative-weighted cycle.\n  if (iteration === adjacencyListSize) {\n    // Empty 'distance' object indicates Negative-Weighted Cycle\n    return {\n      distance: {}\n    };\n  }\n\n  return {\n    distance: minDistance,\n    previous: previousVertex\n  };\n};\n\nmodule.exports = bellmanFord;\n"},"sourceMaps":{"js":{"mappings":[{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":1,"column":0},"generated":{"line":1,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":2,"column":0},"generated":{"line":2,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":3,"column":0},"generated":{"line":3,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":4,"column":0},"generated":{"line":4,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":5,"column":0},"generated":{"line":5,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":6,"column":0},"generated":{"line":6,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":7,"column":0},"generated":{"line":7,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":8,"column":0},"generated":{"line":8,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":9,"column":0},"generated":{"line":9,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":10,"column":0},"generated":{"line":10,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":11,"column":0},"generated":{"line":11,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":12,"column":0},"generated":{"line":12,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":13,"column":0},"generated":{"line":13,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":14,"column":0},"generated":{"line":14,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":15,"column":0},"generated":{"line":15,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":16,"column":0},"generated":{"line":16,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":17,"column":0},"generated":{"line":17,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":18,"column":0},"generated":{"line":18,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":19,"column":0},"generated":{"line":19,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":20,"column":0},"generated":{"line":20,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":21,"column":0},"generated":{"line":21,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":22,"column":0},"generated":{"line":22,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":23,"column":0},"generated":{"line":23,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":24,"column":0},"generated":{"line":24,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":25,"column":0},"generated":{"line":25,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":26,"column":0},"generated":{"line":26,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":27,"column":0},"generated":{"line":27,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":28,"column":0},"generated":{"line":28,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":29,"column":0},"generated":{"line":29,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":30,"column":0},"generated":{"line":30,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":31,"column":0},"generated":{"line":31,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":32,"column":0},"generated":{"line":32,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":33,"column":0},"generated":{"line":33,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":34,"column":0},"generated":{"line":34,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":35,"column":0},"generated":{"line":35,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":36,"column":0},"generated":{"line":36,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":37,"column":0},"generated":{"line":37,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":38,"column":0},"generated":{"line":38,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":39,"column":0},"generated":{"line":39,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":40,"column":0},"generated":{"line":40,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":41,"column":0},"generated":{"line":41,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":42,"column":0},"generated":{"line":42,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":43,"column":0},"generated":{"line":43,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":44,"column":0},"generated":{"line":44,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":45,"column":0},"generated":{"line":45,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":46,"column":0},"generated":{"line":46,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":47,"column":0},"generated":{"line":47,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":48,"column":0},"generated":{"line":48,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":49,"column":0},"generated":{"line":49,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":50,"column":0},"generated":{"line":50,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":51,"column":0},"generated":{"line":51,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":52,"column":0},"generated":{"line":52,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":53,"column":0},"generated":{"line":53,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":54,"column":0},"generated":{"line":54,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":55,"column":0},"generated":{"line":55,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":56,"column":0},"generated":{"line":56,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":57,"column":0},"generated":{"line":57,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":58,"column":0},"generated":{"line":58,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":59,"column":0},"generated":{"line":59,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":60,"column":0},"generated":{"line":60,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":61,"column":0},"generated":{"line":61,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":62,"column":0},"generated":{"line":62,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":63,"column":0},"generated":{"line":63,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":64,"column":0},"generated":{"line":64,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":65,"column":0},"generated":{"line":65,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":66,"column":0},"generated":{"line":66,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":67,"column":0},"generated":{"line":67,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":68,"column":0},"generated":{"line":68,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":69,"column":0},"generated":{"line":69,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":70,"column":0},"generated":{"line":70,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":71,"column":0},"generated":{"line":71,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":72,"column":0},"generated":{"line":72,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":73,"column":0},"generated":{"line":73,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":74,"column":0},"generated":{"line":74,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":75,"column":0},"generated":{"line":75,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":76,"column":0},"generated":{"line":76,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":77,"column":0},"generated":{"line":77,"column":0}},{"source":"node_modules/algorithms/algorithms/graph/bellman_ford.js","original":{"line":78,"column":0},"generated":{"line":78,"column":0}}],"sources":{"node_modules/algorithms/algorithms/graph/bellman_ford.js":"'use strict';\n\n/**\n * Calculates the shortest paths in a graph to every node\n * from the node 'startNode' with Bellman-Ford's algorithm\n *\n * Worst Case Complexity: O(|V| * |E|), where |V| is the number of\n * vertices and |E| is the number of edges in the graph\n *\n * @param Object 'graph' An adjacency list representing the graph\n * @param String 'startNode' The starting node\n * @return Object the minimum distance to reach every vertice of\n *    the graph starting in 'startNode', or an empty object if there\n *    exists a Negative-Weighted Cycle in the graph\n */\nvar bellmanFord = function (graph, startNode) {\n  var minDistance = {};\n  var previousVertex = {};\n  var edges = [];\n  var adjacencyListSize = 0;\n\n  // Add all the edges from the graph to the 'edges' array\n  graph.vertices.forEach(function (s) {\n    graph.neighbors(s).forEach(function (t) {\n      edges.push({\n        source: s,\n        target: t,\n        weight: graph.edge(s, t)\n      });\n    });\n\n    minDistance[s] = Infinity;\n    ++adjacencyListSize;\n  });\n\n  minDistance[startNode] = 0;\n\n  var edgesSize = edges.length;\n  var sourceDistance;\n  var targetDistance;\n\n  var iteration;\n  for (iteration = 0; iteration < adjacencyListSize; ++iteration) {\n    var somethingChanged = false;\n\n    for (var j = 0; j < edgesSize; j++) {\n      sourceDistance = minDistance[edges[j].source] + edges[j].weight;\n      targetDistance = minDistance[edges[j].target];\n\n      if (sourceDistance < targetDistance) {\n        somethingChanged = true;\n        minDistance[edges[j].target] = sourceDistance;\n        previousVertex[edges[j].target] = edges[j].source;\n      }\n    }\n\n    if (!somethingChanged) {\n      // Early stop.\n      break;\n    }\n  }\n\n  // If the loop did not break early, then there is a negative-weighted cycle.\n  if (iteration === adjacencyListSize) {\n    // Empty 'distance' object indicates Negative-Weighted Cycle\n    return {\n      distance: {}\n    };\n  }\n\n  return {\n    distance: minDistance,\n    previous: previousVertex\n  };\n};\n\nmodule.exports = bellmanFord;\n"},"lineCount":78}},"error":null,"hash":"a86d6a9342b465e3d2cae2207ef63ce0","cacheData":{"env":{}}}